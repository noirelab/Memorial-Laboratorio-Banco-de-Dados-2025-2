\documentclass[
12pt,
a4paper,
semrecuonosumario,
sumario = abnt-6027-2012]{report}

% --- Pacotes essenciais
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{geometry}
\geometry{a4paper,margin=2.5cm}
\usepackage{setspace}
\onehalfspacing
\usepackage{graphicx}
\usepackage{float}
\usepackage[hidelinks]{hyperref}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{ragged2e}
\usepackage{indentfirst}




% --- Listagens de código
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny,
  tabsize=2,
  literate={á}{{\'a}}1 {â}{{\^a}}1 {ã}{{\~a}}1 {à}{{\`a}}1
           {Á}{{\'A}}1 {Â}{{\^A}}1 {Ã}{{\~A}}1 {À}{{\`A}}1
           {é}{{\'e}}1 {ê}{{\^e}}1 {É}{{\'E}}1 {Ê}{{\^E}}1
           {í}{{\'i}}1 {Í}{{\'I}}1
           {ó}{{\'o}}1 {ô}{{\^o}}1 {õ}{{\~o}}1 {Ó}{{\'O}}1 {Ô}{{\^O}}1 {Õ}{{\~O}}1
           {ú}{{\'u}}1 {Ú}{{\'U}}1
           {ç}{{\c{c}}}1 {Ç}{{\c{C}}}1
}

% --- (Opcional) Lista de algoritmos – mantida para refletir o PDF
\usepackage{algorithm}
\usepackage{algpseudocode}

% --- Aparência dos títulos
% \titleformat{\chapter}{\bfseries}{\thechapter}{1em}{}
% \titleformat{\section}{\bfseries}{\thesection}{1em}{}
% \titleformat{\subsection}{\bfseries}{\thesubsection}{1em}{}

% --- Dados para a capa/rosto
\newcommand{\universidade}{UNIVERSIDADE TECNOLÓGICA FEDERAL DO PARANÁ}
\newcommand{\autores}{CAIO MACEDO\\ FERNANDO BULIGON ANTUNES\\ JOSÉ SEBEN\\ KAÍQUE MEDEIROS LIMA}
\newcommand{\titulo}{MEMORIAL DESCRITIVO\\Laboratório de Banco de Dados}
\newcommand{\english}{Descriptive Memorial - Database Laboratory}
\newcommand{\docente}{Dra. Leiliane Pereira de Rezende}
\newcommand{\cidade}{SANTA HELENA}
\newcommand{\periodo}{2025/2}

\begin{document}

% --- Capa
\begin{titlepage}
    \centering
    {\bf \universidade\par}
    \vspace{4cm}
    {\bf\autores\par}
    \vspace{6cm}
    {\bf\titulo\par}
    \vspace{9cm}
    {\bf\cidade\par}
    {\bf\periodo\par}
    \newpage

    {\bf\autores\par}
    \vspace{3.5cm}
    {\bf\titulo\par}
    \vspace{2cm}
    {\bf\english\par}
    \vspace{3cm}
    \begin{flushright} % alinha o bloco à direita
        \begin{minipage}{0.5\textwidth} % ocupa metade da largura do texto
        \justifying % vem do pacote ragged2e
        \noindent
        Trabalho de Conclusão de Disciplina de Graduação apresentado como requisito para conclusão da disciplina de Laboratório de Banco de Dados do Curso de Bacharelado em Ciência da Computação da Universidade Tecnológica Federal do Paraná.

        \vspace{1em}
        \noindent
        Docente: Dra. Leiliane Pereira de Rezende
        \end{minipage}
    \end{flushright}
    \vspace{5cm}
    {\bf\cidade\par}
    {\bf\periodo\par}
    \thispagestyle{empty}
\end{titlepage}
\newpage
\setcounter{page}{1}
\section*{\centering \small\bfseries LISTA DE ALGORITMOS}

\newpage
\section*{\centering \small\bfseries LISTA DE FIGURAS}

\newpage
\section*{\centering \small\bfseries LISTAGEM DE CÓDIGOS FONTE}

\newpage
\section*{\centering \small\bfseries LISTA DE ABREVIATURAS E SIGLAS}
\textbf{Siglas}\\

\noindent
ACID\hspace{1cm}Atomicidade, Consistência, Isolamento e Durabilidade
\clearpage

\renewcommand{\cftdotsep}{1}

% --- Título do sumário (compatível com tocloft antigo)
\renewcommand{\contentsname}{\MakeUppercase{Sumário}}
\renewcommand{\cfttoctitlefont}{\bfseries\small} % estilo e tamanho
\renewcommand{\cftaftertoctitle}{\hfill\par}           % segundo \hfill centraliza
\renewcommand{\cftchapfont}{\bfseries}
\renewcommand{\cftchappagefont}{\bfseries}

% --- seções normais (sem negrito)
\renewcommand{\cftsecfont}{\bfseries}
\renewcommand{\cftsecpagefont}{\bfseries}

% --- subseções também normais
\renewcommand{\cftsubsecfont}{\bfseries}
\renewcommand{\cftsubsecpagefont}{\bfseries}

\setlength{\cftbeforetoctitleskip}{0pt}
\setlength{\cftaftertoctitleskip}{2ex}

% Larguras/recuos (alinham número/título/página)
\cftsetindents{chapter}{1em}{4.0em}
\cftsetindents{section}{1em}{4.0em}
\cftsetindents{subsection}{0em}{0em}

% Profundidade do sumário (0=chap, 1=sec, 2=subsec, ...)
\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\titleformat{\chapter}{\bfseries\small}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{2.5ex}{1.5ex}
\titleformat{\section}{\bfseries\small}{\thesection}{1em}{}
\titlespacing*{\section}{0pt}{2.0ex}{1.0ex}


\chapter{BANCO DE DADOS CONCEITUAL/LÓGICO}

	A descrição do BD KJCF\&Cia, trabalhado durante todo o documento, é apresentado na Seção \ref{sec:DescricaoBD}. A modelagem por meio do MER é dada na Seção \ref{sec:mer}. A composição do restante do documento é descrita na Seção \ref{sec:EstruturaTrabalho}.

    \section{Descrição do Banco de Dados}\label{sec:DescricaoBD}
	O BD “KJCF\&Cia” corresponde à modelagem de um processo de banco de dados para uma empresa de materiais de construção, que trabalha desde produtos básicos para obras, ferramentas e utilidades em geral até móveis. Além disso, a empresa oferece serviços adicionais como entrega e montagem para seus clientes. Por se tratar de uma loja situada em uma cidade pequena, as entregas são realizadas apenas dentro da cidade e nas cidades vizinhas.

	As principais informações a serem armazenadas são descritas a seguir:
	\begin{itemize}
	\item Clientes: Cadastro dos clientes que fazem compras na loja.

	\item Cargos: Responsável por armazenar os cargos dos funcionários.

	\item Funcionários: Cadastro dos funcionários da empresa com seus dados.

	\item Categorias: Organização utilizada para separar os produtos por categorias.

	\item Fornecedores: Cadastro dos fornecedores, armazenando suas informações.

	\item Produtos: Cadastro dos produtos da empresa, com suas informações detalhadas.

	\item Estoque: Controle do estoque, registrando os produtos disponíveis em loja.

	\item Compras: Controle das compras realizadas junto aos fornecedores.

	\item Vendas: Registro das vendas realizadas, vinculando clientes e funcionários.

	\item Cidade: Cadastro das cidades relacionadas aos endereços dos clientes.

	\item Bairro: Cadastro dos bairros, vinculados a uma cidade.

	\item Endereço: Armazena o endereço completo dos clientes (rua, número, complemento, bairro e cidade).

	\item Agendamento de Montagem: Controle dos agendamentos de montagens a serem realizadas em produtos vendidos.

	\item Entrega: Controle das entregas vinculadas às vendas, com data e status.

	\item Pagamento Cliente: Registro dos pagamentos efetuados pelos clientes, incluindo forma e status.

	\item Produto Venda: Registro dos itens vendidos em cada venda (produto, quantidade e valor).

	\item Receita Extra: Registro de receitas adicionais recebidas fora do processo de vendas.
\end{itemize}
	Algumas regras são necessárias para que as restrições de integridade do BD sejam mantidas. As principais regras são descritas a abaixo, destacando-se que, ao modelar, algumas são inseridas devido à normalização do BD.

	\begin{itemize}
		\item Regras Sobre os Produtos:
			\begin{itemize}
				\item Deve possuir uma categoria associada e um nome;
				\item Um produto representa um conjunto de produtos com aquele nome e categoria.
			\end{itemize}
		\item Regras sobre os Agendamentos de montagem:
			\begin{itemize}
				\item O Status de montagem deve ser atualizado com frequência
				\item Montagens em atraso devem ser priorizadas
				\item Apenas funcionários de certos cargos podem efetuar a montagem.
			\end{itemize}
		\item Regras sobre a venda de produtos:
			\begin{itemize}
				\item Sempre que um produto é vendido, sua quantidade deve ser alterada no estoque.
			\end{itemize}
		\item Regras sobre as Entregas:
			\begin{itemize}
				\item Entregas devem ser efetuadas na ordem de data, datas mais próximas primeiro.
				\item Entrega só pode ser realizada se a venda for concluída.
			\end{itemize}
		\item Regras sobre os Categorias:
			\begin{itemize}
				\item As categorias devem ser generalizadas. Ex: Produtos de Jardinagem
				\item Deve-se evitar categorias repetidas ou muito semelhantes.
			\end{itemize}
	\end{itemize}

    \section{Modelo Entidade-Relacionamento}\label{sec:mer}
     O MER composto por 17 tabelas é apresentado na Figura~\ref{fig:mer}.

    \begin{figure}[H]
      \centering
      % Ajuste o caminho da imagem conforme sua árvore de pastas
      \includegraphics[width=.9\textwidth]{figuras/01-bdConceitualLog/mer.png}
      \caption{Diagrama Modelo-Entidade}
      \label{fig:mer}
    \end{figure}

    \section{Estrutura do Trabalho}\label{sec:EstruturaTrabalho}
    Após a definição conceitual/lógica, o banco deve ser implementado fisicamente em MySQL.
    Essa implementação, juntamente com a primeira carga de dados, é descrita no Capítulo~\ref{chap:fisico}.

    Com o banco implementado fisicamente, consultas nos dados podem ser realizadas por meio de \texttt{SQL}.
    O Capítulo apresenta inúmeras consultas, cada uma com uma característica diferente.

    Algumas rotinas podem ser definidas para automatizar tarefas e, em alguns casos, melhorar a performance:
    visões, funções, procedimentos, gatilhos e eventos. Esses recursos são tratados no Capítulo~\ref{chap:otimizacao}.

    O acesso aos dados deve ser controlado por segurança. Usuários distintos têm permissões distintas; isso é tratado no Capítulo~\ref{chap:acesso}.

    Para garantir propriedades ACID, operações de alteração devem ser realizadas em bloco de transação (Capítulo~\ref{chap:transacoes}).

    Por fim, falhas podem ocorrer; tolerâncias e tratamentos são descritos no Capítulo~\ref{chap:falhas}.

    \chapter{BANCO DE DADOS FÍSICO}\label{chap:fisico}
    A criação do ``\texttt{KJCF\&Cia}'' considerando MySQL é descrita na Seção~\ref{sec:def-fisica} por meio de DDL.
    A carga inicial é dada na Seção por meio de DML.

    \section{Definição Física}\label{sec:def-fisica}
    Os scripts responsáveis pela criação física do schema são descritos abaixo. Todas as restrições de integridade
    (chaves candidatas, primárias e estrangeiras) são consideradas no momento da criação.

    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_cliente}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_cliente` (
		`id_cliente` INT NOT NULL AUTO_INCREMENT,
		`nome_cliente` VARCHAR(100) NOT NULL,
		`cpf_cnpj_cliente` VARCHAR(20) NOT NULL,
		`telefone_cliente` VARCHAR(20) NOT NULL,
		PRIMARY KEY (`id_cliente`),
		UNIQUE INDEX `cpf_cnpj_cliente_UNIQUE` (`cpf_cnpj_cliente` ASC) VISIBLE)
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_cargo}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_cargo` (
		`id_cargo` INT NOT NULL AUTO_INCREMENT,
		`nome_cargo` VARCHAR(45) NOT NULL,
		`descricao_cargo` VARCHAR(150) NOT NULL,
		`salario_base` DECIMAL(10,2) NOT NULL,
		PRIMARY KEY (`id_cargo`),
		UNIQUE INDEX `descricao_cargo_UNIQUE` (`descricao_cargo` ASC) VISIBLE)
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_funcionario}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_funcionario` (
		`id_funcionario` INT NOT NULL AUTO_INCREMENT,
		`nome_funcionario` VARCHAR(45) NOT NULL,
		`cpf_funcionario` VARCHAR(20) NOT NULL,
		`id_cargo` INT NOT NULL,
		PRIMARY KEY (`id_funcionario`),
		UNIQUE INDEX `cpf_funcionario_UNIQUE` (`cpf_funcionario` ASC) VISIBLE,
		INDEX `id_cargo_idx` (`id_cargo` ASC) VISIBLE,
		CONSTRAINT `fk_funcionario_cargo`
		FOREIGN KEY (`id_cargo`)
		REFERENCES `mydb`.`tb_cargo` (`id_cargo`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_venda}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_venda` (
		`id_venda` INT NOT NULL AUTO_INCREMENT,
		`id_cliente` INT NOT NULL,
		`id_funcionario` INT NOT NULL,
		`data` DATE NOT NULL,
		`status` ENUM('pendente', 'concluida', 'cancelada') NOT NULL,
		`observacao_venda` VARCHAR(200) NULL DEFAULT NULL,
		PRIMARY KEY (`id_venda`),
		INDEX `id_cliente_idx` (`id_cliente` ASC) VISIBLE,
		INDEX `id_funcionario_idx` (`id_funcionario` ASC) VISIBLE,
		CONSTRAINT `fk_venda_cliente`
		FOREIGN KEY (`id_cliente`)
		REFERENCES `mydb`.`tb_cliente` (`id_cliente`),
		CONSTRAINT `fk_venda_funcionario`
		FOREIGN KEY (`id_funcionario`)
		REFERENCES `mydb`.`tb_funcionario` (`id_funcionario`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_cidade}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_cidade` (
		`id_cidade` INT NOT NULL AUTO_INCREMENT,
		`nome_cidade` VARCHAR(150) NOT NULL,
		PRIMARY KEY (`id_cidade`),
		UNIQUE INDEX `nome_cidade_UNIQUE` (`nome_cidade` ASC) VISIBLE)
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_bairro}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_bairro` (
		`id_bairro` INT NOT NULL AUTO_INCREMENT,
		`nome_bairro` VARCHAR(100) NOT NULL,
		`id_cidade` INT NOT NULL,
		PRIMARY KEY (`id_bairro`),
		INDEX `id_cidade_idx` (`id_cidade` ASC) VISIBLE,
		CONSTRAINT `fk_bairro_cidade`
		FOREIGN KEY (`id_cidade`)
		REFERENCES `mydb`.`tb_cidade` (`id_cidade`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_endereco}}]
    	CREATE TABLE IF NOT EXISTS `mydb`.`tb_endereco` (
    	`id_endereco` INT NOT NULL AUTO_INCREMENT,
    	`id_bairro` INT NOT NULL,
    	`logradouro` VARCHAR(150) NOT NULL,
    	`numero` VARCHAR(30) NOT NULL,
    	`complemento` VARCHAR(150) NULL DEFAULT NULL,
    	`id_cliente` INT NOT NULL,
    	`prioridade` TINYINT NULL DEFAULT NULL,
    	PRIMARY KEY (`id_endereco`),
    	INDEX `id_cliente_idx` (`id_cliente` ASC) VISIBLE,
    	INDEX `id_bairro_idx` (`id_bairro` ASC) VISIBLE,
    	CONSTRAINT `fk_endereco_cliente`
    	FOREIGN KEY (`id_cliente`)
    	REFERENCES `mydb`.`tb_cliente` (`id_cliente`),
    	CONSTRAINT `fk_endereco_bairro`
    	FOREIGN KEY (`id_bairro`)
    	REFERENCES `mydb`.`tb_bairro` (`id_bairro`))
    	ENGINE = InnoDB
    	DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_agendamento\_montagem}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_agendamento_montagem` (
		`id_agendamento_montagem` INT NOT NULL AUTO_INCREMENT,
		`id_venda_itens` INT NOT NULL,
		`id_funcionario` INT NOT NULL,
		`id_endereco` INT NOT NULL,
		`data` DATE NOT NULL,
		`status_montagem` ENUM('realizado', 'pendente', 'cancelado') NOT NULL,
		`observacao` TEXT NULL DEFAULT NULL,
		PRIMARY KEY (`id_agendamento_montagem`),
		INDEX `id_venda_itens_idx` (`id_venda_itens` ASC) VISIBLE,
		INDEX `id_funcionario_idx` (`id_funcionario` ASC) VISIBLE,
		INDEX `id_endereco_idx` (`id_endereco` ASC) VISIBLE,
		CONSTRAINT `fk_agendamento_produto_venda`
		FOREIGN KEY (`id_venda_itens`)
		REFERENCES `mydb`.`tb_produto_venda` (`id_venda_itens`),
		CONSTRAINT `fk_agendamento_funcionario`
		FOREIGN KEY (`id_funcionario`)
		REFERENCES `mydb`.`tb_funcionario` (`id_funcionario`),
		CONSTRAINT `fk_agendamento_endereco`
		FOREIGN KEY (`id_endereco`)
		REFERENCES `mydb`.`tb_endereco` (`id_endereco`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_categoria}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_categoria` (
		`id_categoria` INT NOT NULL AUTO_INCREMENT,
		`nome_categoria` VARCHAR(50) NOT NULL,
		`descricao_categoria` VARCHAR(150) NULL DEFAULT NULL,
		PRIMARY KEY (`id_categoria`),
		UNIQUE INDEX `nome_categoria_UNIQUE` (`nome_categoria` ASC) VISIBLE)
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_fornecedor}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_fornecedor` (
		`id_fornecedor` INT NOT NULL AUTO_INCREMENT,
		`nome_fornecedor` VARCHAR(50) NOT NULL,
		`cpf_cnpj_fornecedor` VARCHAR(20) NOT NULL,
		PRIMARY KEY (`id_fornecedor`),
		UNIQUE INDEX `cpf_cnpj_fornecedor_UNIQUE` (`cpf_cnpj_fornecedor` ASC) VISIBLE)
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_compra}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_compra` (
		`id_compra` INT NOT NULL AUTO_INCREMENT,
		`id_fornecedor` INT NOT NULL,
		`data` DATE NOT NULL,
		PRIMARY KEY (`id_compra`),
		INDEX `id_fornecedor_idx` (`id_fornecedor` ASC) VISIBLE,
		CONSTRAINT `fk_compra_fornecedor`
		FOREIGN KEY (`id_fornecedor`)
		REFERENCES `mydb`.`tb_fornecedor` (`id_fornecedor`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_entrega}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_entrega` (
		`id_entrega` INT NOT NULL AUTO_INCREMENT,
		`id_venda` INT NOT NULL,
		`id_endereco` INT NOT NULL,
		`data_entrega` DATE NOT NULL,
		`status_entrega` ENUM('pendente', 'entregue', 'cancelado') NULL DEFAULT 'pendente',
		PRIMARY KEY (`id_entrega`),
		INDEX `id_venda_idx` (`id_venda` ASC) VISIBLE,
		INDEX `id_endereco_idx` (`id_endereco` ASC) VISIBLE,
		CONSTRAINT `fk_entrega_venda`
		FOREIGN KEY (`id_venda`)
		REFERENCES `mydb`.`tb_venda` (`id_venda`),
		CONSTRAINT `fk_entrega_endereco`
		FOREIGN KEY (`id_endereco`)
		REFERENCES `mydb`.`tb_endereco` (`id_endereco`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_produto}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_produto` (
		`id_produto` INT NOT NULL AUTO_INCREMENT,
		`nome_produto` VARCHAR(60) NOT NULL,
		`descricao_produto` VARCHAR(150) NULL DEFAULT NULL,
		`requer_montagem` TINYINT NOT NULL DEFAULT 0,
		`id_categoria` INT NOT NULL,
		PRIMARY KEY (`id_produto`),
		UNIQUE INDEX `nome_produto_UNIQUE` (`nome_produto` ASC) VISIBLE,
		INDEX `id_categoria_idx` (`id_categoria` ASC) VISIBLE,
		CONSTRAINT `fk_produto_categoria`
		FOREIGN KEY (`id_categoria`)
		REFERENCES `mydb`.`tb_categoria` (`id_categoria`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_estoque}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_estoque` (
		`id_estoque` INT NOT NULL AUTO_INCREMENT,
		`id_compra` INT NOT NULL,
		`id_produto` INT NOT NULL,
		`quantidade` INT NOT NULL,
		`preco_estoque` DECIMAL(10,2) NOT NULL,
		PRIMARY KEY (`id_estoque`),
		INDEX `id_compra_idx` (`id_compra` ASC) VISIBLE,
		INDEX `id_produto_idx` (`id_produto` ASC) VISIBLE,
		CONSTRAINT `fk_estoque_compra`
		FOREIGN KEY (`id_compra`)
		REFERENCES `mydb`.`tb_compra` (`id_compra`),
		CONSTRAINT `fk_estoque_produto`
		FOREIGN KEY (`id_produto`)
		REFERENCES `mydb`.`tb_produto` (`id_produto`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_pagamento\_cliente}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_pagamento_cliente` (
		`id_pagamento_cliente` INT NOT NULL AUTO_INCREMENT,
		`id_venda` INT NOT NULL,
		`data_pagamento` DATE NOT NULL,
		`forma_pagamento` ENUM('cartao_credito', 'cartao_debito', 'pix', 'boleto', 'dinheiro') NOT NULL,
		`status_pagamento` ENUM('pendente', 'pago', 'cancelado', 'atrasado') NOT NULL,
		PRIMARY KEY (`id_pagamento_cliente`),
		INDEX `id_venda_idx` (`id_venda` ASC) VISIBLE,
		CONSTRAINT `fk_pagamento_venda`
		FOREIGN KEY (`id_venda`)
		REFERENCES `mydb`.`tb_venda` (`id_venda`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_produto\_venda}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_produto_venda` (
		`id_venda_itens` INT NOT NULL AUTO_INCREMENT,
		`id_venda` INT NOT NULL,
		`id_estoque` INT NOT NULL,
		`quantidade` INT NOT NULL,
		`valor` DECIMAL(10,2) NOT NULL,
		PRIMARY KEY (`id_venda_itens`),
		INDEX `fk_venda_idx` (`id_venda` ASC) VISIBLE,
		INDEX `fk_estoque_idx` (`id_estoque` ASC) VISIBLE,
		CONSTRAINT `fk_produto_venda_to_venda`
		FOREIGN KEY (`id_venda`)
		REFERENCES `mydb`.`tb_venda` (`id_venda`),
		CONSTRAINT `fk_produto_venda_to_estoque`
		FOREIGN KEY (`id_estoque`)
		REFERENCES `mydb`.`tb_estoque` (`id_estoque`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DDL -- Tabela \texttt{tb\_receita\_extra}}]
		CREATE TABLE IF NOT EXISTS `mydb`.`tb_receita_extra` (
		`id_receita` INT NOT NULL AUTO_INCREMENT,
		`descricao_receita` VARCHAR(150) NOT NULL,
		`valor` DECIMAL(10,2) NOT NULL,
		`data_recebimento` DATE NOT NULL,
		`id_funcionario` INT NOT NULL,
		PRIMARY KEY (`id_receita`),
		INDEX `id_funcionario_idx` (`id_funcionario` ASC) VISIBLE,
		CONSTRAINT `fk_receita_funcionario`
		FOREIGN KEY (`id_funcionario`)
		REFERENCES `mydb`.`tb_funcionario` (`id_funcionario`))
		ENGINE = InnoDB
		DEFAULT CHARACTER SET = utf8mb4;
	\end{lstlisting}

    \section{Carga de Dados Iniciais}\label{sec:carga}
    Após a criação do banco, uma carga inicial é inserida por meio de DML:

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_cargo}}]
		INSERT INTO tb_cargo (id_cargo, nome_cargo, descricao_cargo, salario_base) VALUES
		(1,'Vendedor','Responsável pelo atendimento e vendas em loja',2000.00),
		(2,'Montador','Realiza montagem de móveis',2200.00),
		(3,'Gerente','Gerencia a equipe e as metas da loja',4500.00);
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_funcionario}}]
		INSERT INTO tb_funcionario (id_funcionario, nome_funcionario, cpf_funcionario, id_cargo) VALUES
		(1,'José Seben','00000000000',3),
		(2,'Caio Macedo','11111111111',1),
		(3,'Kaique Lima','22222222222',2),
		(4,'Fernando Buligon','33333333333',1);
    \end{lstlisting}
    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_cliente}}]
		INSERT INTO tb_cliente (id_cliente, nome_cliente, cpf_cnpj_cliente, telefone_cliente) VALUES
		(1,'João Oliveira','00000000000','(00) 00000-0000'),
		(2,'Maria Santos','11111111111','(11) 11111-1111'),
		(3,'Eduardo Costa','22222222222','(22) 22222-2222'),
		(4,'Gabriela Barros','33333333333','(33) 33333-3333'),
		(5,'Pedro Cachoeira','44444444444','(44) 44444-4444');
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_cidade}}]
		INSERT INTO tb_cidade (id_cidade, nome_cidade) VALUES
		(1,'Santa Helena'),
		(2,'Sao Clemente'),
		(3,'Medianeira'),
		(4,'Subsede'),
		(5,'Entre Rios');
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_bairro}}]
		INSERT INTO tb_bairro (id_bairro, nome_bairro, id_cidade) VALUES
		(1,'Centro',1),
		(2,'Centro',2),
		(3,'Centro',3),
		(4,'Centro',4),
		(5,'Centro',5);
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_endereco}}]
		INSERT INTO tb_endereco (id_endereco, id_bairro, logradouro, numero, complemento, id_cliente, prioridade) VALUES
		(1,1,'Rua Xaxim','123',NULL,1,1),
		(2,2,'Av. Brasil','321',NULL,2,1),
		(3,3,'Rua Aroeira','231',NULL,3,1),
		(4,4,'Rua Argentina','213',NULL,4,1),
		(5,4,'Rua Argentina','312',NULL,5,1);
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_categoria}}]
		INSERT INTO tb_categoria (id_categoria, nome_categoria, descricao_categoria) VALUES
		(1,'Ferramentas','Makita, martelo, pá...'),
		(2,'Mobilia','Guarda-roupa, mesa, bancada...'),
		(3,'Materiais','Areia, pedra, prego...');
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_fornecedor}}]
		INSERT INTO tb_fornecedor (id_fornecedor, nome_fornecedor, cpf_cnpj_fornecedor) VALUES
		(1,'Kaique Madeiras','22222222222222'),
		(2,'João das Areias','33333333333333'),
		(3,'Pedro Pedradas','44444444444444'),
		(4,'Rafael Pregos','55555555555555'),
		(5,'Raul Rolamentos','66666666666666');
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_produto}}]
		INSERT INTO tb_produto (id_produto, nome_produto, descricao_produto, requer_montagem, id_categoria) VALUES
		(1,'Makita 5007N','Serra Circular 7-1/4 1800W',0,1),
		(2,'Madeira Pinus','Madeira boa',0,3),
		(3,'Mesa Retangular','Mesa de madeira',1,2),
		(4,'Pedra Brita','Essa é da boa',0,3),
		(5,'Areia Média','Funciona bem',0,3);
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_compra}}]
		INSERT INTO tb_compra (id_compra, id_fornecedor, data) VALUES
		(1,1,'2025-08-10'),
		(2,1,'2025-08-11'),
		(3,1,'2025-08-12'),
		(4,1,'2025-08-13');
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_estoque}}]
		INSERT INTO tb_estoque (id_estoque, id_compra, id_produto, quantidade, preco_estoque) VALUES
		(1,1,1, 50, 793.78),
		(2,2,2,100, 120.00),
		(3,2,3, 20, 450.00),
		(4,3,4,200,  35.00),
		(5,4,5,180,  30.00);
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_venda}}]
		INSERT INTO tb_venda (id_venda, id_cliente, id_funcionario, data, status, observacao_venda) VALUES
		(1,1,2,'2025-08-15','concluida','Cara saiu feliz'),
		(2,2,2,'2025-08-16','pendente','Aguardando pagamento'),
		(3,3,4,'2025-08-17','concluida','Sucesso'),
		(4,4,4,'2025-08-18','cancelada','Cartão não passou');
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_produto\_venda}}]
		INSERT INTO tb_produto_venda (id_venda_itens, id_venda, id_estoque, quantidade, valor) VALUES
		(1,1,1,189,793.78),
		(2,2,1,  1,793.78),
		(3,3,1,  1,793.78),
		(4,4,1,  1,793.78);
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_pagamento\_cliente}}]
		INSERT INTO tb_pagamento_cliente (id_pagamento_cliente, id_venda, data_pagamento, forma_pagamento, status_pagamento) VALUES
		(1,1,'2025-08-15','pix','pago'),
		(2,2,'2025-08-17','boleto','pendente'),
		(3,3,'2025-08-17','boleto','pago'),
		(4,4,'2025-08-18','cartao_credito','cancelado');
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_entrega}}]
		INSERT INTO tb_entrega (id_entrega, id_venda, id_endereco, data_entrega, status_entrega) VALUES
		(1,1,1,'2025-08-16','entregue'),
		(2,2,2,'2025-08-20','pendente'),
		(3,3,3,'2025-08-18','entregue');
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_agendamento\_montagem}}]
		INSERT INTO tb_agendamento_montagem (id_agendamento_montagem, id_venda_itens, id_funcionario, id_endereco, data, status_montagem, observacao) VALUES
		(1,1,2,1,'2025-08-16','realizado','Cliente chato'),
		(2,2,2,2,'2025-08-21','pendente','No aguardo da chegada dos materiais'),
		(3,3,2,3,'2025-08-19','realizado','Sucesso');
    \end{lstlisting}

    \begin{lstlisting}[language=SQL,caption={DML -- Tabela \texttt{tb\_receita\_extra}}]
		INSERT INTO tb_receita_extra (id_receita, descricao_receita, valor, data_recebimento, id_funcionario) VALUES
		(1,'Rapaz merece',350.00,'2025-08-19',2),
		(2,'Bateu o recorde em montagem de balcão',120.00,'2025-08-19',3),
		(3,'Comprou makita',150.00,'2025-08-20',1);
    \end{lstlisting}


\chapter{CONSULTAS DE DADOS NO BD}\label{chap:consultas}
    A linguagem SQL permite diferentes recursos para recuperar informações, desde filtros simples até junções complexas e subconsultas. As seções a seguir apresentam as consultas desenvolvidas para validar o banco de dados.

    \section{Restrições de Linha}

    A primeira consulta busca recuperar os dados de clientes específicos filtrando por uma lista de CPFs/CNPJs conhecidos.
    \begin{lstlisting}[language=SQL,caption={Filtro de clientes por lista de CPF/CNPJ}]
        SELECT * FROM tb_cliente
        WHERE cpf_cnpj_cliente IN ('00000000000','11111111111');
    \end{lstlisting}

    Para identificar os cargos com maior remuneração, selecionamos aqueles com salário base superior a R\$ 3.000,00.
    \begin{lstlisting}[language=SQL,caption={Cargos com salário superior a R\$ 3.000}]
        SELECT * FROM tb_cargo
        WHERE salario_base > 3000.00;
    \end{lstlisting}

    A listagem de funcionários abaixo filtra apenas aqueles que ocupam o cargo de "Vendedor" (identificado pelo ID 1).
    \begin{lstlisting}[language=SQL,caption={Listagem de Vendedores}]
        SELECT * FROM tb_funcionario
        WHERE id_cargo = 1;
    \end{lstlisting}

    Para relatório de fechamento, buscamos todas as vendas que já possuem o status de 'concluida'.
    \begin{lstlisting}[language=SQL,caption={Vendas com status concluído}]
        SELECT * FROM tb_venda
        WHERE status = 'concluida';
    \end{lstlisting}

    A consulta a seguir filtra cidades de uma região específica (Santa Helena e Medianeira) para análise logística.
    \begin{lstlisting}[language=SQL,caption={Filtro de Cidades da região}]
        SELECT * FROM tb_cidade
        WHERE nome_cidade IN ('Santa Helena','Medianeira');
    \end{lstlisting}

    Buscamos os bairros denominados 'Centro' que pertencem especificamente às cidades de ID 4 e 5.
    \begin{lstlisting}[language=SQL,caption={Bairros do centro em cidades específicas}]
        SELECT * FROM tb_bairro
        WHERE nome_bairro = 'Centro'
        AND id_cidade IN (4,5);
    \end{lstlisting}

    Para verificar a consistência de cadastros, buscamos endereços de clientes selecionados que não possuem complemento cadastrado.
    \begin{lstlisting}[language=SQL,caption={Endereços sem complemento de clientes específicos}]
        SELECT * FROM tb_endereco
        WHERE id_cliente IN (1,5)
        AND complemento IS NULL;
    \end{lstlisting}

    Para controle de qualidade, listamos as montagens realizadas a partir do dia 19/08/2025.
    \begin{lstlisting}[language=SQL,caption={Montagens realizadas recentemente}]
        SELECT * FROM tb_agendamento_montagem
        WHERE status_montagem = 'realizado'
        AND data >= '2025-08-19';
    \end{lstlisting}

    A consulta abaixo lista todas as categorias de produtos, exceto a categoria de 'Ferramentas'.
    \begin{lstlisting}[language=SQL,caption={Categorias exceto Ferramentas}]
        SELECT * FROM tb_categoria
        WHERE nome_categoria <> 'Ferramentas';
    \end{lstlisting}

    Utilizando o operador \texttt{LIKE}, buscamos fornecedores cujo CNPJ inicia com os dígitos '33'.
    \begin{lstlisting}[language=SQL,caption={Busca de fornecedor por início do CNPJ}]
        SELECT * FROM tb_fornecedor
        WHERE cpf_cnpj_fornecedor LIKE '33%';
    \end{lstlisting}

    Para auditar as aquisições, listamos as compras feitas com o Fornecedor 1 a partir de 12/08/2025.
    \begin{lstlisting}[language=SQL,caption={Compras recentes de um fornecedor específico}]
        SELECT * FROM tb_compra
        WHERE id_fornecedor = 1
        AND data >= '2025-08-12';
    \end{lstlisting}

    A logística precisa monitorar entregas pendentes ou que estão agendadas para datas futuras (pós 17/08/2025).
    \begin{lstlisting}[language=SQL,caption={Entregas pendentes ou futuras}]
        SELECT * FROM tb_entrega
        WHERE status_entrega = 'pendente'
        OR data_entrega > '2025-08-17';
    \end{lstlisting}

    Listamos produtos da categoria 3 (Materiais) que possuem uma descrição detalhada preenchida.
    \begin{lstlisting}[language=SQL,caption={Produtos da categoria 3 com descrição}]
        SELECT * FROM tb_produto
        WHERE id_categoria = 3
        AND descricao_produto IS NOT NULL;
    \end{lstlisting}

    Para gestão de inventário, buscamos lotes de estoque com grande volume (mais de 100 itens) e custo unitário baixo (até R\$ 120,00).
    \begin{lstlisting}[language=SQL,caption={Itens de estoque de alto volume e baixo custo}]
        SELECT * FROM tb_estoque
        WHERE quantidade >= 100
        AND preco_estoque <= 120.00;
    \end{lstlisting}

    O setor financeiro necessita listar pagamentos via Pix ou Boleto que já foram efetivados ('pago').
    \begin{lstlisting}[language=SQL,caption={Pagamentos efetivados via Pix ou Boleto}]
        SELECT * FROM tb_pagamento_cliente
        WHERE forma_pagamento IN ('pix','boleto')
        AND status_pagamento = 'pago';
    \end{lstlisting}

    Para análise de saída de produtos, verificamos itens de venda do produto 1 onde a quantidade vendida foi alta (>= 100).
    \begin{lstlisting}[language=SQL,caption={Grandes saídas do Produto 1}]
        SELECT * FROM tb_produto_venda
        WHERE id_produto = 1
        AND quantidade >= 100;
    \end{lstlisting}

    Por fim, filtramos receitas extras de alto valor (>= 150.00) recebidas em um intervalo de datas específico.
    \begin{lstlisting}[language=SQL,caption={Receitas extras altas no período}]
        SELECT * FROM tb_receita_extra
        WHERE data_recebimento BETWEEN '2025-08-19' AND '2025-08-20'
        AND valor >= 150.00;
    \end{lstlisting}

    \section{Funções de Linha}

    As funções de linha permitem manipular dados no momento da projeção. Abaixo, convertemos o nome da categoria para maiúsculo e contamos seus caracteres.
    \begin{lstlisting}[language=SQL,caption={Manipulação de Strings (UPPER e LENGTH)}]
        SELECT id_categoria,
               nome_categoria,
               UPPER(nome_categoria) AS nome_maiusculo,
               LENGTH(nome_categoria) AS tam
        FROM tb_categoria;
    \end{lstlisting}

    Para apresentar o CPF formatado em relatórios, utilizamos concatenação e \textit{substrings}.
    \begin{lstlisting}[language=SQL,caption={Formatação de máscara de CPF}]
        SELECT id_cliente,
               nome_cliente,
               CONCAT(
                 SUBSTRING(cpf_cnpj_cliente,1,3),'.',
                 SUBSTRING(cpf_cnpj_cliente,4,3),'.',
                 SUBSTRING(cpf_cnpj_cliente,7,3),'-',
                 SUBSTRING(cpf_cnpj_cliente,10,2)
               ) AS cpf_formatado
        FROM tb_cliente
        WHERE CHAR_LENGTH(cpf_cnpj_cliente) = 11;
    \end{lstlisting}

    A função \texttt{COALESCE} é utilizada para garantir que o endereço seja exibido corretamente mesmo quando o complemento é nulo.
    \begin{lstlisting}[language=SQL,caption={Concatenação segura de Endereço}]
        SELECT id_endereco,
               CONCAT(
                 logradouro, ', ', numero,
                 COALESCE(CONCAT(' - ', complemento), '')
               ) AS endereco_completo
        FROM tb_endereco;
    \end{lstlisting}

    Manipulações de data são essenciais. Abaixo formatamos a data para o padrão brasileiro e calculamos a "idade" da venda em dias.
    \begin{lstlisting}[language=SQL,caption={Formatação de Data e Diferença de Dias}]
        SELECT id_venda,
               DATE_FORMAT(data, '%d/%m/%Y') AS data_br,
               DATEDIFF(CURDATE(), data)     AS dias_desde_a_venda
        FROM tb_venda;
    \end{lstlisting}

    Utilizamos a estrutura condicional \texttt{CASE} para classificar o valor total dos itens vendidos em faixas (alto, médio, baixo).
    \begin{lstlisting}[language=SQL,caption={Lógica condicional com CASE}]
        SELECT id_venda_itens,
               quantidade,
               valor,
               ROUND(quantidade * valor, 2) AS total_item,
               CASE
                 WHEN quantidade * valor >= 1000 THEN 'alto'
                 WHEN quantidade * valor >= 100  THEN 'médio'
                 ELSE 'baixo'
               END AS faixa_valor
        FROM tb_produto_venda;
    \end{lstlisting}


    \section{Junções de Tabelas}

    As junções permitem relacionar dados distribuídos. A consulta a seguir usa \texttt{INNER JOIN} para mostrar o nome da categoria ao lado do produto.
    \begin{lstlisting}[language=SQL,caption={Junção Produto e Categoria}]
        SELECT p.id_produto,
               p.nome_produto,
               c.nome_categoria
        FROM tb_produto p
        INNER JOIN tb_categoria c
                ON c.id_categoria = p.id_categoria;
    \end{lstlisting}

    Para calcular o total de uma venda e saber quem comprou, realizamos junções em cadeia entre Venda, Cliente e Itens da Venda.
    \begin{lstlisting}[language=SQL,caption={Total de Venda por Cliente}]
        SELECT v.id_venda,
               cl.nome_cliente,
               SUM(pv.quantidade * pv.valor) AS total_venda
        FROM tb_venda v
        INNER JOIN tb_cliente cl
                ON cl.id_cliente = v.id_cliente
        INNER JOIN tb_produto_venda pv
                ON pv.id_venda = v.id_venda
        GROUP BY v.id_venda, cl.nome_cliente;
    \end{lstlisting}

    Utilizamos \texttt{LEFT JOIN} para listar todas as compras, trazendo dados do estoque quando existirem (preservando compras que ainda não deram entrada no estoque, se houver).
    \begin{lstlisting}[language=SQL,caption={Compras e entrada no Estoque}]
        SELECT co.id_compra,
               f.nome_fornecedor,
               e.id_estoque,
               e.quantidade
        FROM tb_compra co
        INNER JOIN tb_fornecedor f
                ON f.id_fornecedor = co.id_fornecedor
        LEFT JOIN tb_estoque e
               ON e.id_compra = co.id_compra
        ORDER BY co.id_compra;
    \end{lstlisting}

    O conceito de \textit{Anti-Join} é aplicado para descobrir cidades cadastradas que ainda não possuem nenhum bairro vinculado.
    \begin{lstlisting}[language=SQL,caption={Cidades sem bairros cadastrados}]
        SELECT ci.id_cidade,
               ci.nome_cidade
        FROM tb_cidade ci
        LEFT JOIN tb_bairro b
               ON b.id_cidade = ci.id_cidade
        WHERE b.id_bairro IS NULL;
    \end{lstlisting}

    Uma \texttt{SELF JOIN} é utilizada na tabela de funcionários para encontrar pares de colegas que possuem o mesmo cargo.
    \begin{lstlisting}[language=SQL,caption={Pares de funcionários do mesmo cargo}]
        SELECT f1.nome_funcionario AS funcionario_1,
               f2.nome_funcionario AS funcionario_2,
               c.nome_cargo
        FROM tb_funcionario f1
        INNER JOIN tb_funcionario f2
                ON f1.id_cargo = f2.id_cargo
               AND f1.id_funcionario < f2.id_funcionario
        INNER JOIN tb_cargo c
                ON c.id_cargo = f1.id_cargo;
    \end{lstlisting}


    \section{Operadores de Conjunto}

    O operador \texttt{UNION} é utilizado para criar uma lista única contendo nomes de clientes e fornecedores, removendo duplicatas.
    \begin{lstlisting}[language=SQL,caption={União de Clientes e Fornecedores}]
        SELECT nome_cliente AS nome, 'cliente' AS origem
        FROM tb_cliente
        UNION
        SELECT nome_fornecedor AS nome, 'fornecedor' AS origem
        FROM tb_fornecedor;
    \end{lstlisting}

    Diferente do anterior, o \texttt{UNION ALL} mantém registros duplicados, útil para contagens totais de entidades.
    \begin{lstlisting}[language=SQL,caption={União total (com duplicatas)}]
        SELECT nome_cliente AS nome
        FROM tb_cliente
        UNION ALL
        SELECT nome_fornecedor AS nome
        FROM tb_fornecedor;
    \end{lstlisting}

    Simulamos um \texttt{INTERSECT} utilizando \texttt{EXISTS} para encontrar nomes que figuram tanto como clientes quanto como fornecedores.
    \begin{lstlisting}[language=SQL,caption={Interseção de nomes (Cliente e Fornecedor)}]
        SELECT c.nome_cliente AS nome
        FROM tb_cliente c
        WHERE EXISTS (
            SELECT 1
            FROM tb_fornecedor f
            WHERE f.nome_fornecedor = c.nome_cliente
        );
    \end{lstlisting}

    Simulamos o operador \texttt{EXCEPT} (ou MINUS) para listar clientes que estão cadastrados, mas que nunca realizaram uma compra (Venda).
    \begin{lstlisting}[language=SQL,caption={Clientes sem compras (Except)}]
        SELECT c.id_cliente, c.nome_cliente
        FROM tb_cliente c
        WHERE NOT EXISTS (
            SELECT 1
            FROM tb_venda v
            WHERE v.id_cliente = c.id_cliente
        );
    \end{lstlisting}

    Por fim, unimos cidades e bairros em uma única coluna para listagem geográfica geral.
    \begin{lstlisting}[language=SQL,caption={Lista geográfica unificada}]
        SELECT nome_cidade AS nome, 'cidade' AS tipo
        FROM tb_cidade
        UNION
        SELECT nome_bairro AS nome, 'bairro' AS tipo
        FROM tb_bairro;
    \end{lstlisting}


    \section{Sub-Consultas}

    Subconsultas escalares retornam um único valor. Abaixo, buscamos cargos que pagam o teto salarial da empresa (o maior salário base encontrado).
    \begin{lstlisting}[language=SQL,caption={Cargos com o maior salário base}]
        SELECT nome_cargo, salario_base
        FROM tb_cargo
        WHERE salario_base = (
            SELECT MAX(salario_base) FROM tb_cargo
        );
    \end{lstlisting}

    Utilizamos \texttt{IN} com subconsulta para obter os dados dos clientes que possuem pelo menos uma venda com status 'concluida'.
    \begin{lstlisting}[language=SQL,caption={Clientes com vendas concluídas}]
        SELECT c.id_cliente, c.nome_cliente
        FROM tb_cliente c
        WHERE c.id_cliente IN (
            SELECT v.id_cliente
            FROM tb_venda v
            WHERE v.status = 'concluida'
        );
    \end{lstlisting}

    A subconsulta correlacionada com \texttt{EXISTS} filtra os fornecedores para exibir apenas aqueles com quem já realizamos compras.
    \begin{lstlisting}[language=SQL,caption={Fornecedores ativos em compras}]
        SELECT f.id_fornecedor, f.nome_fornecedor
        FROM tb_fornecedor f
        WHERE EXISTS (
            SELECT 1
            FROM tb_compra co
            WHERE co.id_fornecedor = f.id_fornecedor
        );
    \end{lstlisting}

    Podemos filtrar vendas com base em um cálculo agregado na subconsulta. Aqui, buscamos vendas cujo valor total exceda R\$ 1.000,00.
    \begin{lstlisting}[language=SQL,caption={Vendas de alto valor (Correlacionada)}]
        SELECT v.id_venda, v.data, v.status
        FROM tb_venda v
        WHERE (
            SELECT SUM(pv.valor * pv.quantidade)
            FROM tb_produto_venda pv
            WHERE pv.id_venda = v.id_venda
        ) > 1000.00;
    \end{lstlisting}

    Utilizando uma tabela derivada (subconsulta no \texttt{FROM}), calculamos as 5 categorias com maior volume de itens vendidos.
    \begin{lstlisting}[language=SQL,caption={Top 5 Categorias por volume de vendas}]
        SELECT d.id_categoria, d.nome_categoria, d.qtd_itens
        FROM (
            SELECT pr.id_categoria,
                   ca.nome_categoria,
                   SUM(pv.quantidade) AS qtd_itens
            FROM tb_produto_venda pv
            JOIN tb_estoque es  ON es.id_estoque  = pv.id_estoque
            JOIN tb_produto pr  ON pr.id_produto  = es.id_produto
            JOIN tb_categoria ca ON ca.id_categoria = pr.id_categoria
            GROUP BY pr.id_categoria, ca.nome_categoria
        ) AS d
        ORDER BY d.qtd_itens DESC
        LIMIT 5;
    \end{lstlisting}

    Com \texttt{NOT EXISTS}, identificamos produtos que exigem montagem mas que, curiosamente, nunca foram vendidos (não constam em itens de venda).
    \begin{lstlisting}[language=SQL,caption={Produtos com montagem sem saída}]
        SELECT p.id_produto, p.nome_produto
        FROM tb_produto p
        WHERE p.requer_montagem = 1
          AND NOT EXISTS (
              SELECT 1
              FROM tb_estoque e
              JOIN tb_produto_venda pv ON pv.id_estoque = e.id_estoque
              WHERE e.id_produto = p.id_produto
          );
    \end{lstlisting}

    Subconsultas na projeção (dentro do \texttt{SELECT}) permitem trazer dados agregados linha a linha. Abaixo, trazemos o total de cada venda junto aos seus dados.
    \begin{lstlisting}[language=SQL,caption={Total calculado na projeção}]
        SELECT v.id_venda,
               v.status,
               (
                 SELECT SUM(pv.valor * pv.quantidade)
                 FROM tb_produto_venda pv
                 WHERE pv.id_venda = v.id_venda
               ) AS total_venda
        FROM tb_venda v;
    \end{lstlisting}


    \section{Agregação e Funções de Agrupamento}

    Para relatórios gerenciais, contamos quantos funcionários existem em cada cargo utilizando \texttt{GROUP BY}.
    \begin{lstlisting}[language=SQL,caption={Contagem de funcionários por cargo}]
        SELECT
               c.nome_cargo,
               COUNT(f.id_funcionario) AS total_funcionarios
        FROM tb_funcionario f
        INNER JOIN tb_cargo c ON f.id_cargo = c.id_cargo
        GROUP BY c.id_cargo, c.nome_cargo;
    \end{lstlisting}

    Calculamos o valor financeiro imobilizado em estoque, agrupado por produto.
    \begin{lstlisting}[language=SQL,caption={Valor total em estoque por produto}]
        SELECT
               p.nome_produto,
               SUM(e.quantidade * e.preco_estoque) AS valor_total_estoque
        FROM tb_estoque e
        INNER JOIN tb_produto p ON e.id_produto = p.id_produto
        GROUP BY p.id_produto, p.nome_produto;
    \end{lstlisting}

    Utilizamos a cláusula \texttt{HAVING} para filtrar grupos após a agregação. Aqui, listamos apenas clientes que gastaram mais de R\$ 1.000,00 no total.
    \begin{lstlisting}[language=SQL,caption={Clientes VIP (Gasto > 1000)}]
        SELECT
               c.nome_cliente,
               SUM(pv.quantidade * pv.valor) AS total_gasto
        FROM tb_cliente c
        JOIN tb_venda v ON c.id_cliente = v.id_cliente
        JOIN tb_produto_venda pv ON v.id_venda = pv.id_venda
        GROUP BY c.id_cliente, c.nome_cliente
        HAVING total_gasto > 1000.00;
    \end{lstlisting}


    \section{\texttt{SELECT} nos Comandos DML}

    É possível utilizar o resultado de um \texttt{SELECT} para alimentar um comando \texttt{INSERT}. Abaixo, criamos uma receita extra de bônus automaticamente para todos os vendedores.
    \begin{lstlisting}[language=SQL,caption={Inserção em massa (Bônus para Vendedores)}]
        INSERT INTO tb_receita_extra (descricao_receita, valor, data_recebimento, id_funcionario)
        SELECT
            'Bônus de desempenho geral',
            25.00,
            CURDATE(),
            id_funcionario
        FROM tb_funcionario
        WHERE id_cargo = 1;
    \end{lstlisting}

    Podemos atualizar registros com base em uma subconsulta. O comando a seguir cancela todas as vendas da cliente 'Gabriela Barros'.
    \begin{lstlisting}[language=SQL,caption={Update com Subconsulta}]
        UPDATE tb_venda
        SET status = 'cancelada'
        WHERE id_cliente = (
            SELECT id_cliente
            FROM tb_cliente
            WHERE nome_cliente = 'Gabriela Barros'
        );
    \end{lstlisting}

    Da mesma forma, podemos deletar registros dependentes. O comando abaixo remove pagamentos vinculados a vendas que foram canceladas.
    \begin{lstlisting}[language=SQL,caption={Delete com Subconsulta}]
        DELETE FROM tb_pagamento_cliente
        WHERE id_venda IN (
            SELECT id_venda
            FROM tb_venda
            WHERE status = 'cancelada'
        );
    \end{lstlisting}

\chapter{ROTINAS DE OTIMIZAÇÃO NO BD}\label{chap:otimizacao}
    \section{Visões}
    Visões são tabelas virtuais que não existem fisicamente, é visível para o usuário e apenas a sua definição é armazenada. Elas são utilizadas para evitar problemas relacionados a segurança e facilidade na consulta, permitindo que o acesso seja confidencial, simples e sem alterar a estrutura do banco de dados original. Exemplos de possíveis utilizações das visões:
    \begin{lstlisting}[language=SQL,caption={VIEW -- venda por funcionário }]
    	CREATE VIEW vw_vendaFuncionario
    	AS SELECT id_venda, tb_venda.id_funcionario, nome_funcionario, data, status
    	FROM tb_venda
    	JOIN tb_funcionario ON tb_funcionario.id_funcionario = tb_venda.id_funcionario;
    	);
    \end{lstlisting}
    
    \begin{lstlisting}[language=SQL,caption={VIEW -- View para produto e sua categoria }]
    	CREATE VIEW vw_produtoCategoria(nome, descricao, requer_montagem, categoria)
    	AS (SELECT nome_produto, descricao_produto, requer_montagem, tb_produto.id_categoria
    	FROM tb_produto
    	JOIN tb_categoria ON tb_categoria.id_categoria = tb_produto.id_categoria);
    \end{lstlisting}
    
    \section{Funções}
    Uma função é um procedimento armazenado dentro do servidor que é executada sempre que chamada. Ela deve retornar um valor de retorno e é utilizada para fazer parte de uma expressão ou parâmetro. Com uma função, não é possível alterar o estado atual do banco de dados. Essa função pode ser chamada tanto por um procedimento quanto para um SELECT. Exemplos de possíveis usos de funções:
    \begin{lstlisting}[language=SQL,caption={FUNCTION -- Retorna o faturamento com vendas no mês}]
    	DELIMITER //
    	create function VENDA_NO_MES(mes int, ano int)
    	returns decimal(10,2)
    	begin
    	declare valor_total decimal(10,2);
    	
    	select sum(valor) into valor_total
    	from tb_produto_venda
    	inner join tb_venda on tb_venda.id_venda = tb_produto_venda.id_venda
    	where month(tb_venda.data) = mes
    	and year(tb_venda.data) = ano;
    	
    	return IFNULL(valor_total, 0.00);
    	
    	end; //
    	);
    \end{lstlisting}
    

    \section{Procedimentos}
    Procedimentos Armazenados (\textit{Stored Procedures}) são conjuntos de comandos SQL pré-compilados e armazenados no servidor de banco de dados. Eles permitem encapsular lógica de negócios, reutilizar código, melhorar a segurança e, em muitos casos, aumentar o desempenho ao reduzir o tráfego de rede.

    Abaixo são apresentados exemplos de procedimentos criados para automatizar tarefas comuns no sistema KJCF\&Cia.

    \begin{lstlisting}[language=SQL,caption={Procedure -- Atualizar preço no estoque por percentual}]
        DELIMITER $$

        CREATE PROCEDURE pr_reajustar_preco_estoque (
            IN p_id_produto INT,
            IN p_percentual DECIMAL(5,2)
        )
        BEGIN
            -- Atualiza o preco do produto no estoque baseado em um percentual
            -- Ex: 10.0 representa um aumento de 10%
            UPDATE tb_estoque
            SET preco_estoque = preco_estoque * (1 + (p_percentual / 100))
            WHERE id_produto = p_id_produto;
        END $$

        DELIMITER ;
    \end{lstlisting}

    Para chamar o procedimento acima e aplicar um aumento de 10\% no produto de ID 1:
    \begin{lstlisting}[language=SQL,caption={Exemplo de chamada -- \texttt{pr\_reajustar\_preco\_estoque}}]
        CALL pr_reajustar_preco_estoque(1, 10.00);
    \end{lstlisting}

    Outro uso comum é a geração de relatórios encapsulados. O procedimento a seguir retorna o histórico de vendas de um cliente específico dentro de um período.

    \begin{lstlisting}[language=SQL,caption={Procedure -- Histórico de compras do cliente}]
        DELIMITER $$

        CREATE PROCEDURE pr_historico_cliente (
            IN p_id_cliente INT,
            IN p_data_inicio DATE,
            IN p_data_fim DATE
        )
        BEGIN
            SELECT
                v.id_venda,
                v.data,
                v.status,
                SUM(pv.quantidade * pv.valor) AS valor_total
            FROM tb_venda v
            INNER JOIN tb_produto_venda pv ON v.id_venda = pv.id_venda
            WHERE v.id_cliente = p_id_cliente
              AND v.data BETWEEN p_data_inicio AND p_data_fim
            GROUP BY v.id_venda, v.data, v.status
            ORDER BY v.data DESC;
        END $$

        DELIMITER ;
    \end{lstlisting}

    Por fim, procedimentos podem utilizar parâmetros de saída (\texttt{OUT}) para retornar valores calculados para a aplicação ou para outros blocos SQL.

    \begin{lstlisting}[language=SQL,caption={Procedure -- Calcular comissão total de funcionário (OUT)}]
        DELIMITER $$

        CREATE PROCEDURE pr_calcular_total_vendas_funcionario (
            IN p_id_funcionario INT,
            OUT p_total_vendido DECIMAL(10,2)
        )
        BEGIN
            -- Calcula a soma total das vendas concluidas realizadas pelo funcionario
            SELECT SUM(pv.quantidade * pv.valor)
            INTO p_total_vendido
            FROM tb_venda v
            INNER JOIN tb_produto_venda pv ON v.id_venda = pv.id_venda
            WHERE v.id_funcionario = p_id_funcionario
              AND v.status = 'concluida';

            -- Se nao houver vendas, define como 0
            IF p_total_vendido IS NULL THEN
                SET p_total_vendido = 0.00;
            END IF;
        END $$

        DELIMITER ;
    \end{lstlisting}

    \section{Gatilhos}
    \dots

    \section{Eventos}
    \dots

\chapter{CONTROLE DE ACESSO}\label{chap:acesso}
O controle de acesso é dado por \texttt{GRANT} e \texttt{REVOKE}. As subseções a seguir seguem o PDF.

    \section{Criar Usuários}
    \dots

    \section{Atribuir Permissões}
    \dots

    \section{Revogar Permissões}
    \dots

\chapter{TRANSAÇÕES NO BD}\label{chap:transacoes}
Defina blocos transacionais atômicos para preservar ACID.
\dots

\chapter{FALHAS NO BD}\label{chap:falhas}
Durante a execução de qualquer software, falhas podem ocorrer; tolerâncias e tratamentos devem ser estabelecidos.

    \section{Tolerâncias à Falhas}
    \dots

    \section{Tratamento à Falhas}
    \dots

% --- Referências (livre; substitua por biblatex se quiser)
\clearpage
\chapter*{REFERÊNCIAS}
\addcontentsline{toc}{chapter}{REFERÊNCIAS}
% Insira suas referências manualmente ou troque para biblatex.
\vspace{-0.5em}
\begin{itemize}
  \item \dots
\end{itemize}

\end{document}
